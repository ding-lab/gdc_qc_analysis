---
title: "Recoverable unique calls"
author: "Liang-Bo Wang"
date: '2018-06-04'
output: html_notebook
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(DBI)
library(RSQLite)
```

Connect to the SQLite database. Tweak SQLite caching strategy to use more memory (about 4GB).
```{r, results='hide'}
conn = dbConnect(RSQLite::SQLite(), dbname='../processed_data/all_variants.somatic_only.sqlite')
dbExecute(conn, 'PRAGMA cache_size=-4000000')
dbExecute(conn, 'PRAGMA temp_store=MEMORY')
```

Read full overlap table into memory.
```{r}
overlap_tbl <- as.tibble(dbReadTable(conn, 'full_overlap'))
```

Read recoverable unique calls.
```{r, results='hide'}
gdc_recoverable_unique_tbl <- read_tsv(
    '../processed_data/gdc_recoverable_unique_variants.tsv.gz',
    col_types = cols(
        .default = col_character(),
        start_position = col_integer(), end_position = col_integer(),
        mc3_t_depth = col_integer(), mc3_t_ref_count = col_integer(), mc3_t_alt_count = col_integer(),
        mc3_n_depth = col_integer(), mc3_n_ref_count = col_integer(), mc3_n_alt_count = col_integer(),
        overlap_rowid = col_integer(), gdc_rowid = col_integer(), mc3_protected_rowid = col_integer()
    )
)
gdc_filters_tbl <- read_tsv('../processed_data/gdc_recoverable_unique_variants.filter_cols.tsv.gz') 
mc3_recoverable_unique_tbl <- read_tsv(
    '../processed_data/mc3_recoverable_unique_variants.tsv.gz',
        col_types = cols(
        .default = col_character(),
        start_position = col_integer(), end_position = col_integer(),
        mc3_t_depth = col_integer(), mc3_t_ref_count = col_integer(), mc3_t_alt_count = col_integer(),
        mc3_n_depth = col_integer(), mc3_n_ref_count = col_integer(), mc3_n_alt_count = col_integer(),
        overlap_rowid = col_integer(), mc3_rowid = col_integer(), gdc_protected_rowid = col_integer()
    )
)
mc3_filters_tbl <- read_tsv('../processed_data/mc3_recoverable_unique_variants.filter_cols.tsv.gz')

# Merge with its filter columns
gdc_tbl <- bind_cols(gdc_recoverable_unique_tbl, gdc_filters_tbl)
mc3_tbl <- bind_cols(mc3_recoverable_unique_tbl, mc3_filters_tbl)
```


## GDC Filter analysis

A quick overview of the filter flags.
```{r}
gdc_tbl %>%
    group_by(gdc_filter, gdc_gdc_filter, mc3_filter) %>%
    summarize(n = n()) %>% arrange(-n) %>%
    filter(n >= 100)
```

```{r}
gdc_filters <- gdc_tbl %>%
    select(starts_with('gdc__'), starts_with('gdc_gdc__')) %>%
    summarise_all(sum) %>% 
    gather(key = "filter", value = "count") %>%
    arrange(-count)

mc3_filters <- gdc_tbl %>%
    select(starts_with('mc3__')) %>%
    summarise_all(sum) %>% 
    gather(key = "filter", value = "count") %>%
    arrange(-count)
    
gdc_filters
mc3_filters
```

Interesting comparison filter pairs:
- PASS:
    - gdc__PASS gdc__PASS vs mc3__PASS
- WGA: 
    - gdc_gdc__wga_pair, gdc_gdc__wga_tumor, gdc_gdc__wga_normal vs mc3__wga
- bitgt: Target .bed file (Broad); outside of the target design probes, implying non-common-capture regions.
- PoN:
    - gdc_gdc__gdc_pon, gdc__panel_of_normals vs mc3__broad_PoN_v2
    - gdc__panel_of_normals will have gdc_gdc__gdc_pon but not otherwise
- NonExonic:
    - gdc_gdc__NonExonic vs mc3__NonExonic


### GDC calls with MC3 PASS filter
```{r}
gdc_calls <- gdc_tbl %>% filter(mc3_filter == 'PASS')
nrow(gdc_calls)
```

```{r}
gdc_calls %>% count(mc3_callers, sort = TRUE)
gdc_calls %>% count(gdc_filter, gdc_gdc_filter, sort = TRUE) %>% filter(n >= 10)
```

Exclude those calls from the rest of the analysis
```{r}
remaining_gdc_calls <- gdc_tbl %>% filter(mc3_filter != 'PASS')
```


### GDC calls with MC3 one-caller:
```{r}
remaining_gdc_calls %>% count(mc3_ncallers, sort = TRUE)
```

Exclude those calls from the rest of the analysis
```{r}
remaining_gdc_calls <- remaining_gdc_calls %>% filter(mc3_ncallers > 1)
```



### GDC calls with MC3 NonExonic filter: 
```{r}
gdc_calls <- remaining_gdc_calls %>% filter(mc3__NonExonic == 1)
nrow(gdc_calls)
```

```{r}
gdc_calls %>% count(gdc_filter, gdc_gdc_filter, sort = TRUE) %>% head(10)
```


```{r}
gdc_calls %>% filter(gdc_gdc__wga_pair == 1 | gdc_gdc__wga_normal == 1 | gdc_gdc__wga_tumor == 1) %>% nrow
gdc_calls %>% filter(gdc_gdc__NonExonic == 1) %>% nrow
gdc_calls %>% filter(gdc_gdc__bitgt == 1) %>% nrow
gdc_calls %>% filter(gdc_gdc__bitgt == 1 | gdc_gdc__NonExonic == 1) %>% nrow
```

```{r}
gdc_calls %>% count(gdc_variant_classification, sort = TRUE)
```

```{r}
gdc_calls %>% filter(gdc_variant_classification %in% c('Intron', 'RNA', "5'Flank", "3'Flank", "3'UTR", "5'UTR", "IGR")) %>% nrow
gdc_calls %>% filter(gdc_variant_classification %in% c('Splice_Region', 'Splice_Site')) %>% nrow
```

```{r}
gdc_calls %>% 
    filter(gdc_variant_classification %in% c('Missense_Mutation', 'Nonsense_Mutation', 'Silent', 'Nonstop_Mutation')) %>%
    nrow

gdc_calls %>% 
    filter(gdc_variant_classification %in% c('Missense_Mutation', 'Nonsense_Mutation', 'Silent', 'Nonstop_Mutation')) %>%
    count(gdc_hugo_symbol, mc3_hugo_symbol, sort = TRUE) %>%
    filter(n >= 10)
```

Exclude those calls from the rest of the analysis
```{r}
remaining_gdc_calls <- remaining_gdc_calls %>% filter(mc3__NonExonic == 0)
```

```{r}
remaining_gdc_calls %>%
    count(gdc_filter, gdc_gdc_filter, mc3_filter, sort = TRUE) %>% 
    head(20)
```


### GDC calls with MC3 PoN filter:

```{r}
gdc_calls <- remaining_gdc_calls %>% filter(mc3__broad_PoN_v2 == 1)
nrow(gdc_calls)
```

```{r}
gdc_calls %>% count(gdc_filter, gdc_gdc_filter, mc3_filter, sort=TRUE) %>% head(20)
```

```{r}
gdc_calls %>% filter(gdc__panel_of_normals == 1 | gdc_gdc__gdc_pon == 1) %>% nrow
gdc_calls %>% filter(gdc_gdc__) %>% nrow
gdc_calls %>% filter(gdc__panel_of_normals == 1 | gdc_gdc__gdc_pon == 1) %>% 
    count(gdc_variant_classification, sort = TRUE)
```


Exclude those calls from the rest of the analysis
```{r}
remaining_gdc_calls <- remaining_gdc_calls %>% filter(mc3__broad_PoN_v2 == 0)
```



### GDC calls with MC3 Target seq BED region:

```{r}
gdc_calls <- remaining_gdc_calls %>% filter(mc3__bitgt == 1)
gdc_calls %>% count(gdc_filter, gdc_gdc__bitgt, sort = TRUE)
```

```{r}
gdc_calls %>% filter(gdc_filter == 'PASS' & gdc_gdc__bitgt == 0) %>%
    count(gdc_gdc_filter, mc3_filter, sort = TRUE)
```

```{r}
remaining_gdc_calls <- remaining_gdc_calls %>% filter(mc3__bitgt == 0)
```


```{r}
remaining_gdc_calls %>%
    count(gdc_filter, gdc_gdc_filter, mc3_filter, sort=TRUE)
```





## MC3 filter analysis
```{r}
gdc_filters <- mc3_tbl %>%
    select(starts_with('gdc__'), starts_with('gdc_gdc__')) %>%
    summarise_all(sum) %>% 
    gather(key = "filter", value = "count") %>%
    arrange(-count)

mc3_filters <- mc3_tbl %>%
    select(starts_with('mc3__')) %>%
    summarise_all(sum) %>% 
    gather(key = "filter", value = "count") %>%
    arrange(-count)
    
gdc_filters
mc3_filters
```



## MC3 recoverable unique filter analysis

```{r}
mc3_tbl %>%
    group_by(gdc_filter, gdc_gdc_filter, mc3_filter) %>%
    summarize(n = n()) %>% arrange(-n) %>%
    filter(n >= 100)
```


```{r}
ggplot(data = remaining_gdc_calls %>% mutate(mc3_vaf = mc3_t_alt_count / mc3_t_depth)) +
    geom_point(aes(x=mc3_t_depth, y=mc3_t_alt_count))
```

```{r}
ggplot(data = gdc_recover_pass %>% mutate(mc3_vaf = mc3_t_alt_count / mc3_t_depth)) +
    geom_point(aes(x=mc3_n_depth, y=mc3_n_alt_count))
```

```{r}
gdc_recover_pass %>%
    filter(gdc_reference_allele == mc3_reference_allele) %>%
    filter(gdc_tumor_seq_allele1 != mc3_tumor_seq_allele1) %>%
    nrow
```


